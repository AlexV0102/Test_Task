# Test_Task
## **Суттєві зміни у алгоритмі**
### Завдання № 1.
Замість запису диграфів та літер у матрицу, та подальшу роботу з нею. Виконується безспосередня робота із стрічкою
```
        std::vector<std::string> encrypted(keys.size());
        // Цикл по стрічці, який по черзі бере диграф та одну літеру
        // та додає їх у масив стрічок у відповідне місце згідню ключа
        for (int i = 0, j = 0; i < str.size();)
        {       
                // Диграф
                if (i + 1 < str.size()) {
                    encrypted[keys[j] - '0' - 1] += str.substr(i, 2);
                    i += 2;
                    j++;
                    if (j == keys.size()) {
                        j = 0; 
                    }
                }
                // Одна літера
                if (i < str.size()) {
                    encrypted[keys[j] - '0' - 1] += str[i];
                    i++;
                    j++;
                    if (j == keys.size()) {
                        j = 0; 
                    }
                }
        }
 ```
### Завдання № 2.
Перероблено знаходження наступних елементів послідовності <br>
```
  int size = numbers.size();
  for (int i = 0; i < 3; i++)
  {
    // Формула для знаходження наступних трьох елементів
    // а(nі) = a0 + d_11*(n-1 + i) + d_21 * T(n) + d_31
    // Де: 1) а(nі) - шукані числа
    //	   2) і - лічильник для знаходження трьох елементів
    //	   3) d_11, d_21, d_31 числа взяті із різниць послідовності
    //	   4) T(n) - трикутне число, яке знаходиться за формолую T(n) = n*(n+1)/2, у коді додан лічильник і задля 
    //         знаходження всіх трьох наступних елементів
    // Примітка: d_31 є елементом з різниці послідовностей, які дорівнюють нулю
    int num = numbers.front() + sequence[0] * (size + i) + sequence[1] * ((size + i - 1) * (size + i) / 2);
    result.push_back(num);
  }
```
